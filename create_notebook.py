#!/usr/bin/env python3
"""
Create the Jupyter notebook with proper JSON structure
"""

import json

def create_notebook():
    """Create the Dynamic Pricing Elf Guide notebook"""
    
    notebook = {
        "cells": [
            # Cell 1: Title and Introduction
            {
                "cell_type": "markdown",
                "metadata": {},
                "source": [
                    "# üßù‚Äç‚ôÇÔ∏è The Elves' Guide to Dynamic Pricing Magic ‚ú®\n",
                    "\n",
                    "---\n",
                    "\n",
                    "**Welcome, dear apprentice!** Step into the enchanted world of the Elves' Marketplace, where pricing isn't just numbers on a tag‚Äîit's **pure magic**! üé©‚ú®\n",
                    "\n",
                    "## üè∞ What is This Mystical Art?\n",
                    "\n",
                    "Imagine if prices could dance and change like the Northern Lights, responding to the rhythm of demand, the whispers of the seasons, and the ebb and flow of our treasure chests (inventory). This is **Dynamic Pricing**‚Äîthe ancient elven art of finding the \"*just right*\" price for every moment!\n",
                    "\n",
                    "### üéØ The Quest Ahead\n",
                    "\n",
                    "In this magical journey, you'll discover:\n",
                    "- üìä **The Elves' Marketplace Ledger**: Explore our treasure trove of sales data\n",
                    "- üßô‚Äç‚ôÇÔ∏è **Pricing Spells & Potions**: Learn the fundamental concepts\n",
                    "- ‚öóÔ∏è **Crafting Price Potions**: Build magical algorithms that adjust prices\n",
                    "- üí∞ **Counting the Gold**: Evaluate which strategies bring the most treasure\n",
                    "- üåü **Wisdom for Your Own Kingdom**: Take these secrets back to your realm\n",
                    "\n",
                    "### üé≠ Meet Your Guide\n",
                    "\n",
                    "I'm **Pricewinkle the Wise**, your friendly elf guide! I've been managing pricing magic in our marketplace for over 200 seasons. Don't worry if you're new to this‚ÄîI'll explain everything as if you're my favorite apprentice! üßù‚Äç‚ôÇÔ∏èüìö\n",
                    "\n",
                    "---\n",
                    "\n",
                    "*Ready to begin? Let's cast our first spell by importing the magical libraries we'll need!* ‚ú®"
                ]
            },
            
            # Cell 2: Import libraries
            {
                "cell_type": "code",
                "execution_count": None,
                "metadata": {},
                "outputs": [],
                "source": [
                    "# üßô‚Äç‚ôÇÔ∏è Importing Our Magical Libraries\n",
                    "import pandas as pd\n",
                    "import numpy as np\n",
                    "import matplotlib.pyplot as plt\n",
                    "import seaborn as sns\n",
                    "import plotly.express as px\n",
                    "import plotly.graph_objects as go\n",
                    "from plotly.subplots import make_subplots\n",
                    "import ipywidgets as widgets\n",
                    "from IPython.display import display, HTML\n",
                    "from sklearn.linear_model import LinearRegression\n",
                    "from sklearn.model_selection import train_test_split\n",
                    "from sklearn.metrics import mean_squared_error, r2_score\n",
                    "import warnings\n",
                    "from datetime import datetime, timedelta\n",
                    "\n",
                    "# üé® Making our plots beautiful\n",
                    "plt.style.use('seaborn-v0_8')\n",
                    "sns.set_palette(\"husl\")\n",
                    "warnings.filterwarnings('ignore')\n",
                    "\n",
                    "print(\"‚ú® All magical libraries imported successfully! ‚ú®\")\n",
                    "print(\"üßù‚Äç‚ôÇÔ∏è Pricewinkle says: 'We're ready to explore the data!'\")"
                ]
            },
            
            # Cell 3: Section 1 - Dataset Loading
            {
                "cell_type": "markdown",
                "metadata": {},
                "source": [
                    "# üìö The Elves' Marketplace: Our Treasure Trove of Data\n",
                    "\n",
                    "---\n",
                    "\n",
                    "Welcome to our **Marketplace Ledger**! This ancient tome contains every transaction from our enchanted marketplace over the past year. Each entry tells a story of supply, demand, and the delicate dance of pricing magic! üìñ‚ú®"
                ]
            },
            
            # Cell 4: Load and explore data
            {
                "cell_type": "code",
                "execution_count": None,
                "metadata": {},
                "outputs": [],
                "source": [
                    "# üìñ Loading the Elves' Marketplace Ledger\n",
                    "print(\"üßù‚Äç‚ôÇÔ∏è Pricewinkle: 'Let me open our ancient ledger for you...'\")\n",
                    "\n",
                    "# Load the data\n",
                    "df = pd.read_csv('elves_marketplace_data.csv')\n",
                    "df['timestamp'] = pd.to_datetime(df['timestamp'])\n",
                    "\n",
                    "print(f\"üìä Our ledger contains {len(df):,} magical transactions!\")\n",
                    "print(f\"üóìÔ∏è From {df['timestamp'].min().date()} to {df['timestamp'].max().date()}\")\n",
                    "print(f\"üõçÔ∏è Featuring {df['product_id'].nunique()} unique products\")\n",
                    "print(f\"üë• Served {df['customer_id'].nunique()} valued customers\")\n",
                    "\n",
                    "print(\"\\n‚ú® Let's peek at the first few entries in our ledger:\")\n",
                    "display(df.head(10))"
                ]
            },
            
            # Cell 5: Data overview
            {
                "cell_type": "code",
                "execution_count": None,
                "metadata": {},
                "outputs": [],
                "source": [
                    "# üîç A Closer Look at Our Data\n",
                    "print(\"üßù‚Äç‚ôÇÔ∏è Pricewinkle: 'Let me show you the structure of our magical data!'\")\n",
                    "print(\"\\nüìã Data Information:\")\n",
                    "df.info()\n",
                    "\n",
                    "print(\"\\nüìä Statistical Summary:\")\n",
                    "display(df.describe())\n",
                    "\n",
                    "print(\"\\nüè™ Our Product Categories:\")\n",
                    "category_counts = df['category'].value_counts()\n",
                    "for category, count in category_counts.items():\n",
                    "    print(f\"  {category}: {count:,} transactions\")"
                ]
            },
            
            # Cell 6: Interactive data exploration
            {
                "cell_type": "code",
                "execution_count": None,
                "metadata": {},
                "outputs": [],
                "source": [
                    "# üéÆ Interactive Data Explorer\n",
                    "print(\"üßù‚Äç‚ôÇÔ∏è Pricewinkle: 'Try these magical controls to explore our data!'\")\n",
                    "\n",
                    "# Create interactive widgets\n",
                    "category_dropdown = widgets.Dropdown(\n",
                    "    options=['All'] + list(df['category'].unique()),\n",
                    "    value='All',\n",
                    "    description='Category:',\n",
                    "    style={'description_width': 'initial'}\n",
                    ")\n",
                    "\n",
                    "price_slider = widgets.FloatRangeSlider(\n",
                    "    value=[df['price_paid'].min(), df['price_paid'].max()],\n",
                    "    min=df['price_paid'].min(),\n",
                    "    max=df['price_paid'].max(),\n",
                    "    step=1.0,\n",
                    "    description='Price Range:',\n",
                    "    style={'description_width': 'initial'}\n",
                    ")\n",
                    "\n",
                    "def update_data_view(category, price_range):\n",
                    "    filtered_df = df.copy()\n",
                    "    \n",
                    "    if category != 'All':\n",
                    "        filtered_df = filtered_df[filtered_df['category'] == category]\n",
                    "    \n",
                    "    filtered_df = filtered_df[\n",
                    "        (filtered_df['price_paid'] >= price_range[0]) & \n",
                    "        (filtered_df['price_paid'] <= price_range[1])\n",
                    "    ]\n",
                    "    \n",
                    "    print(f\"‚ú® Found {len(filtered_df):,} magical transactions matching your criteria!\")\n",
                    "    \n",
                    "    if len(filtered_df) > 0:\n",
                    "        print(f\"üí∞ Average price: {filtered_df['price_paid'].mean():.2f} gold coins\")\n",
                    "        print(f\"üì¶ Average quantity: {filtered_df['quantity'].mean():.1f} items\")\n",
                    "        display(filtered_df[['product_name', 'category', 'price_paid', 'quantity', 'timestamp']].head())\n",
                    "\n",
                    "# Create interactive widget\n",
                    "interactive_explorer = widgets.interactive(update_data_view, category=category_dropdown, price_range=price_slider)\n",
                    "display(interactive_explorer)"
                ]
            },
            
            # Cell 7: Visual storytelling
            {
                "cell_type": "code",
                "execution_count": None,
                "metadata": {},
                "outputs": [],
                "source": [
                    "# üìä Visual Stories from Our Data\n",
                    "print(\"üßù‚Äç‚ôÇÔ∏è Pricewinkle: 'Pictures tell the best stories! Let me show you...'\")\n",
                    "\n",
                    "# Create subplots for comprehensive view\n",
                    "fig, axes = plt.subplots(2, 2, figsize=(15, 12))\n",
                    "fig.suptitle('üé® The Elves\\' Marketplace in Pictures', fontsize=16, fontweight='bold')\n",
                    "\n",
                    "# 1. Price distribution\n",
                    "axes[0,0].hist(df['price_paid'], bins=50, alpha=0.7, color='skyblue', edgecolor='black')\n",
                    "axes[0,0].set_title('üí∞ Distribution of Prices (Gold Coins)')\n",
                    "axes[0,0].set_xlabel('Price Paid')\n",
                    "axes[0,0].set_ylabel('Number of Transactions')\n",
                    "\n",
                    "# 2. Sales by category\n",
                    "category_sales = df.groupby('category')['quantity'].sum().sort_values(ascending=True)\n",
                    "axes[0,1].barh(category_sales.index, category_sales.values, color='lightgreen')\n",
                    "axes[0,1].set_title('üõçÔ∏è Total Items Sold by Category')\n",
                    "axes[0,1].set_xlabel('Total Quantity Sold')\n",
                    "\n",
                    "# 3. Revenue over time\n",
                    "df['revenue'] = df['price_paid'] * df['quantity']\n",
                    "monthly_revenue = df.groupby(df['timestamp'].dt.to_period('M'))['revenue'].sum()\n",
                    "axes[1,0].plot(range(len(monthly_revenue)), monthly_revenue.values, marker='o', color='gold', linewidth=2)\n",
                    "axes[1,0].set_title('üìà Monthly Revenue Trends')\n",
                    "axes[1,0].set_xlabel('Month')\n",
                    "axes[1,0].set_ylabel('Revenue (Gold Coins)')\n",
                    "axes[1,0].tick_params(axis='x', rotation=45)\n",
                    "\n",
                    "# 4. Price vs Original Price scatter\n",
                    "axes[1,1].scatter(df['original_price'], df['price_paid'], alpha=0.5, color='purple')\n",
                    "axes[1,1].plot([df['original_price'].min(), df['original_price'].max()], \n",
                    "               [df['original_price'].min(), df['original_price'].max()], \n",
                    "               'r--', label='Equal Price Line')\n",
                    "axes[1,1].set_title('üéØ Original vs Actual Prices')\n",
                    "axes[1,1].set_xlabel('Original Price')\n",
                    "axes[1,1].set_ylabel('Price Paid')\n",
                    "axes[1,1].legend()\n",
                    "\n",
                    "plt.tight_layout()\n",
                    "plt.show()\n",
                    "\n",
                    "print(\"\\n‚ú® What do these magical charts tell us?\")\n",
                    "print(\"üí° Dynamic pricing is already at work - prices paid often differ from original prices!\")"
                ]
            },
            
            # Cell 8: Key concepts introduction
            {
                "cell_type": "markdown",
                "metadata": {},
                "source": [
                    "# üßô‚Äç‚ôÇÔ∏è The Elves' Pricing Spells: Understanding the Magic\n",
                    "\n",
                    "---\n",
                    "\n",
                    "Now that we've explored our data, let **Pricewinkle the Wise** teach you the fundamental concepts behind pricing magic! ‚ú®\n",
                    "\n",
                    "## üé≠ What is Dynamic Pricing?\n",
                    "\n",
                    "**Dynamic Pricing** is like having a wise shop assistant who constantly adjusts prices based on:\n",
                    "- üåü **Customer Demand**: More people want it? Price goes up!\n",
                    "- üì¶ **Inventory Levels**: Running low? Time to increase the price!\n",
                    "- üóìÔ∏è **Time & Seasonality**: Holiday season? Prices dance higher!\n",
                    "- üë• **Customer Segments**: Loyal customers might get special treatment\n",
                    "- üè™ **Competition**: What are other shops charging?\n",
                    "\n",
                    "## üéØ The Magic Behind the Curtain\n",
                    "\n",
                    "Think of dynamic pricing as **three types of spells**:\n",
                    "\n",
                    "### 1. üìö **Rule-Based Magic** (Simple but Powerful!)\n",
                    "- \"*If inventory < 10 items, increase price by 20%*\"\n",
                    "- \"*If it's a holiday, add 15% premium*\"\n",
                    "- \"*If demand is high, raise price by 25%*\"\n",
                    "\n",
                    "### 2. üßÆ **Mathematical Spells** (Using Ancient Algorithms!)\n",
                    "- **Linear Regression**: Finding the invisible thread between price and demand\n",
                    "- **Machine Learning**: Teaching our systems to learn from patterns\n",
                    "\n",
                    "### 3. üß† **Learning Magic** (Advanced Sorcery!)\n",
                    "- **Reinforcement Learning**: Systems that learn from trial and error\n",
                    "- **Neural Networks**: Digital brains that recognize complex patterns\n",
                    "\n",
                    "---\n",
                    "\n",
                    "*Ready to brew your first pricing potion? Let's start with some simple magic!* üß™‚ú®"
                ]
            },
            
            # Cell 9: Algorithm 1 - Rule-based pricing
            {
                "cell_type": "code",
                "execution_count": None,
                "metadata": {},
                "outputs": [],
                "source": [
                    "# üß™ Brewing Our First Pricing Potion - Rule-Based Magic!\n",
                    "print(\"üßù‚Äç‚ôÇÔ∏è Pricewinkle: 'Let's start with simple but powerful rule-based pricing!'\")\n",
                    "\n",
                    "def rule_based_pricing(original_price, inventory_level, is_holiday, is_weekend, customer_segment):\n",
                    "    \"\"\"\n",
                    "    üßô‚Äç‚ôÇÔ∏è The Elves' Rule-Based Pricing Spell\n",
                    "    \n",
                    "    This magical function applies simple rules to adjust prices:\n",
                    "    - Low inventory = higher prices\n",
                    "    - Holidays = premium pricing  \n",
                    "    - Weekends = slight increase\n",
                    "    - Customer loyalty = discounts\n",
                    "    \"\"\"\n",
                    "    adjusted_price = original_price\n",
                    "    adjustments = []\n",
                    "    \n",
                    "    # Rule 1: Inventory-based pricing\n",
                    "    if inventory_level < 10:\n",
                    "        multiplier = 1.25  # 25% increase for low stock\n",
                    "        adjusted_price *= multiplier\n",
                    "        adjustments.append(f\"üì¶ Low stock (+{(multiplier-1)*100:.0f}%)\")\n",
                    "    elif inventory_level > 80:\n",
                    "        multiplier = 0.95  # 5% discount for high stock\n",
                    "        adjusted_price *= multiplier\n",
                    "        adjustments.append(f\"üì¶ High stock ({(multiplier-1)*100:.0f}%)\")\n",
                    "    \n",
                    "    # Rule 2: Holiday premium\n",
                    "    if is_holiday:\n",
                    "        multiplier = 1.20  # 20% holiday premium\n",
                    "        adjusted_price *= multiplier\n",
                    "        adjustments.append(f\"üéÑ Holiday season (+{(multiplier-1)*100:.0f}%)\")\n",
                    "    \n",
                    "    # Rule 3: Weekend premium\n",
                    "    if is_weekend:\n",
                    "        multiplier = 1.10  # 10% weekend premium\n",
                    "        adjusted_price *= multiplier\n",
                    "        adjustments.append(f\"üåÖ Weekend (+{(multiplier-1)*100:.0f}%)\")\n",
                    "    \n",
                    "    # Rule 4: Customer loyalty discount\n",
                    "    if customer_segment == 'Loyal':\n",
                    "        multiplier = 0.90  # 10% loyalty discount\n",
                    "        adjusted_price *= multiplier\n",
                    "        adjustments.append(f\"üëë Loyal customer ({(multiplier-1)*100:.0f}%)\")\n",
                    "    \n",
                    "    return round(adjusted_price, 2), adjustments\n",
                    "\n",
                    "# Test our rule-based pricing\n",
                    "print(\"\\nüß™ Testing Our Rule-Based Pricing Spell:\")\n",
                    "print(\"=\"*50)\n",
                    "\n",
                    "test_cases = [\n",
                    "    (50.0, 5, True, True, 'New'),        # Low stock + Holiday + Weekend + New customer\n",
                    "    (30.0, 90, False, False, 'Loyal'),   # High stock + Regular day + Loyal customer\n",
                    "    (75.0, 50, True, False, 'Regular'),  # Normal stock + Holiday + Regular customer\n",
                    "]\n",
                    "\n",
                    "for i, (price, inventory, holiday, weekend, segment) in enumerate(test_cases, 1):\n",
                    "    new_price, adjustments = rule_based_pricing(price, inventory, holiday, weekend, segment)\n",
                    "    print(f\"\\nüìã Test Case {i}:\")\n",
                    "    print(f\"   Original Price: {price} gold coins\")\n",
                    "    print(f\"   Inventory Level: {inventory}\")\n",
                    "    print(f\"   Holiday: {'Yes' if holiday else 'No'}\")\n",
                    "    print(f\"   Weekend: {'Yes' if weekend else 'No'}\")\n",
                    "    print(f\"   Customer: {segment}\")\n",
                    "    print(f\"   ‚ú® Final Price: {new_price} gold coins\")\n",
                    "    print(f\"   üìù Adjustments: {', '.join(adjustments) if adjustments else 'None'}\")\n",
                    "    print(f\"   üìä Change: {((new_price/price - 1) * 100):+.1f}%\")\n",
                    "\n",
                    "print(\"\\nüéâ Our rule-based pricing spell is working perfectly!\")"
                ]
            },
            
            # Cell 10: Interactive rule-based pricing
            {
                "cell_type": "code",
                "execution_count": None,
                "metadata": {},
                "outputs": [],
                "source": [
                    "# üéÆ Interactive Rule-Based Pricing Simulator\n",
                    "print(\"üßù‚Äç‚ôÇÔ∏è Pricewinkle: 'Now you try! Adjust the magical dials and see prices change!'\")\n",
                    "\n",
                    "# Create interactive widgets\n",
                    "price_input = widgets.FloatSlider(value=50.0, min=10.0, max=200.0, step=5.0, description='Original Price:')\n",
                    "inventory_input = widgets.IntSlider(value=50, min=0, max=100, description='Inventory:')\n",
                    "holiday_input = widgets.Checkbox(value=False, description='Holiday Season')\n",
                    "weekend_input = widgets.Checkbox(value=False, description='Weekend')\n",
                    "segment_input = widgets.Dropdown(options=['New', 'Regular', 'Loyal', 'High-Value'], value='Regular', description='Customer:')\n",
                    "\n",
                    "def interactive_pricing(original_price, inventory, is_holiday, is_weekend, customer_segment):\n",
                    "    new_price, adjustments = rule_based_pricing(original_price, inventory, is_holiday, is_weekend, customer_segment)\n",
                    "    \n",
                    "    print(f\"üè∑Ô∏è Original Price: {original_price:.2f} gold coins\")\n",
                    "    print(f\"‚ú® Adjusted Price: {new_price:.2f} gold coins\")\n",
                    "    print(f\"üìä Total Change: {((new_price/original_price - 1) * 100):+.1f}%\")\n",
                    "    \n",
                    "    if adjustments:\n",
                    "        print(f\"\\nüîÆ Applied Spells:\")\n",
                    "        for adjustment in adjustments:\n",
                    "            print(f\"   ‚Ä¢ {adjustment}\")\n",
                    "    else:\n",
                    "        print(\"\\nüòå No price adjustments needed - standard pricing applies!\")\n",
                    "    \n",
                    "    # Visual representation\n",
                    "    if new_price > original_price:\n",
                    "        print(f\"\\nüìà Price increased by {new_price - original_price:.2f} gold coins\")\n",
                    "    elif new_price < original_price:\n",
                    "        print(f\"\\nüìâ Price decreased by {original_price - new_price:.2f} gold coins\")\n",
                    "    else:\n",
                    "        print(f\"\\n‚û°Ô∏è Price remains unchanged\")\n",
                    "\n",
                    "# Create the interactive widget\n",
                    "pricing_simulator = widgets.interactive(\n",
                    "    interactive_pricing,\n",
                    "    original_price=price_input,\n",
                    "    inventory=inventory_input,\n",
                    "    is_holiday=holiday_input,\n",
                    "    is_weekend=weekend_input,\n",
                    "    customer_segment=segment_input\n",
                    ")\n",
                    "\n",
                    "display(pricing_simulator)"
                ]
            },
            
            # Cell 11: Algorithm 2 - Linear Regression
            {
                "cell_type": "code",
                "execution_count": None,
                "metadata": {},
                "outputs": [],
                "source": [
                    "# üßÆ Advanced Magic: Linear Regression Price Optimization\n",
                    "print(\"üßù‚Äç‚ôÇÔ∏è Pricewinkle: 'Now for some advanced sorcery - mathematical price prediction!'\")\n",
                    "\n",
                    "# Prepare data for machine learning\n",
                    "print(\"üìä Preparing our data for the mathematical spell...\")\n",
                    "\n",
                    "# Create features for our model\n",
                    "df['price_difference'] = df['price_paid'] - df['original_price']\n",
                    "df['is_weekend'] = df['timestamp'].dt.weekday >= 5\n",
                    "df['month'] = df['timestamp'].dt.month\n",
                    "df['day_of_year'] = df['timestamp'].dt.dayofyear\n",
                    "\n",
                    "# Select features for our model\n",
                    "features = [\n",
                    "    'original_price', 'inventory_level_before_sale', 'holiday_season',\n",
                    "    'is_weekend', 'competitor_price_avg', 'month'\n",
                    "]\n",
                    "\n",
                    "# Prepare the data\n",
                    "X = df[features].copy()\n",
                    "\n",
                    "# Convert boolean to numeric\n",
                    "X['is_weekend'] = X['is_weekend'].astype(int)\n",
                    "\n",
                    "# Target variable: quantity sold (demand)\n",
                    "y = df['quantity']\n",
                    "\n",
                    "# Split the data\n",
                    "X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)\n",
                    "\n",
                    "# Train the model\n",
                    "print(\"üßô‚Äç‚ôÇÔ∏è Training our magical demand prediction model...\")\n",
                    "demand_model = LinearRegression()\n",
                    "demand_model.fit(X_train, y_train)\n",
                    "\n",
                    "# Make predictions\n",
                    "y_pred = demand_model.predict(X_test)\n",
                    "\n",
                    "# Evaluate the model\n",
                    "mse = mean_squared_error(y_test, y_pred)\n",
                    "r2 = r2_score(y_test, y_pred)\n",
                    "\n",
                    "print(f\"\\nüìä Model Performance:\")\n",
                    "print(f\"   R¬≤ Score: {r2:.3f} (Higher is better, max 1.0)\")\n",
                    "print(f\"   Mean Squared Error: {mse:.3f}\")\n",
                    "\n",
                    "# Show feature importance\n",
                    "print(f\"\\nüîç Which factors most influence demand?\")\n",
                    "feature_importance = pd.DataFrame({\n",
                    "    'Feature': features,\n",
                    "    'Importance': np.abs(demand_model.coef_)\n",
                    "}).sort_values('Importance', ascending=False)\n",
                    "\n",
                    "for idx, row in feature_importance.iterrows():\n",
                    "    print(f\"   {row['Feature']}: {row['Importance']:.3f}\")\n",
                    "\n",
                    "print(\"\\n‚ú® Our mathematical spell can predict demand based on various factors!\")"
                ]
            },
            
            # Cell 12: Demand prediction function
            {
                "cell_type": "code",
                "execution_count": None,
                "metadata": {},
                "outputs": [],
                "source": [
                    "# üéØ Creating an Intelligent Pricing Function\n",
                    "print(\"üßù‚Äç‚ôÇÔ∏è Pricewinkle: 'Let me show you how to use our demand model for smart pricing!'\")\n",
                    "\n",
                    "def predict_optimal_price(original_price, inventory_level, is_holiday, is_weekend, \n",
                    "                         competitor_price, month=6, price_steps=20):\n",
                    "    \"\"\"\n",
                    "    üßô‚Äç‚ôÇÔ∏è The Elves' Intelligent Pricing Spell\n",
                    "    \n",
                    "    This function uses our trained model to find the price that maximizes revenue!\n",
                    "    \"\"\"\n",
                    "    \n",
                    "    # Test different price points\n",
                    "    min_price = original_price * 0.7  # 30% discount max\n",
                    "    max_price = original_price * 1.5  # 50% premium max\n",
                    "    \n",
                    "    test_prices = np.linspace(min_price, max_price, price_steps)\n",
                    "    revenues = []\n",
                    "    demands = []\n",
                    "    \n",
                    "    for test_price in test_prices:\n",
                    "        # Create feature vector for prediction\n",
                    "        features_array = np.array([[\n",
                    "            test_price,  # original_price -> test_price\n",
                    "            inventory_level,\n",
                    "            1 if is_holiday else 0,\n",
                    "            1 if is_weekend else 0,\n",
                    "            competitor_price,\n",
                    "            month\n",
                    "        ]])\n",
                    "        \n",
                    "        # Predict demand\n",
                    "        predicted_demand = demand_model.predict(features_array)[0]\n",
                    "        # Ensure demand is positive\n",
                    "        predicted_demand = max(0.1, predicted_demand)\n",
                    "        \n",
                    "        # Calculate revenue\n",
                    "        revenue = test_price * predicted_demand\n",
                    "        \n",
                    "        revenues.append(revenue)\n",
                    "        demands.append(predicted_demand)\n",
                    "    \n",
                    "    # Find optimal price\n",
                    "    optimal_idx = np.argmax(revenues)\n",
                    "    optimal_price = test_prices[optimal_idx]\n",
                    "    optimal_demand = demands[optimal_idx]\n",
                    "    optimal_revenue = revenues[optimal_idx]\n",
                    "    \n",
                    "    return {\n",
                    "        'optimal_price': optimal_price,\n",
                    "        'predicted_demand': optimal_demand,\n",
                    "        'predicted_revenue': optimal_revenue,\n",
                    "        'price_change_pct': ((optimal_price / original_price) - 1) * 100,\n",
                    "        'test_prices': test_prices,\n",
                    "        'revenues': revenues,\n",
                    "        'demands': demands\n",
                    "    }\n",
                    "\n",
                    "# Test the intelligent pricing\n",
                    "print(\"\\nüß™ Testing Our Intelligent Pricing Spell:\")\n",
                    "print(\"=\"*50)\n",
                    "\n",
                    "test_scenarios = [\n",
                    "    {'original_price': 50.0, 'inventory_level': 5, 'is_holiday': True, 'is_weekend': True, 'competitor_price': 55.0},\n",
                    "    {'original_price': 30.0, 'inventory_level': 90, 'is_holiday': False, 'is_weekend': False, 'competitor_price': 28.0},\n",
                    "    {'original_price': 100.0, 'inventory_level': 25, 'is_holiday': True, 'is_weekend': False, 'competitor_price': 105.0}\n",
                    "]\n",
                    "\n",
                    "for i, scenario in enumerate(test_scenarios, 1):\n",
                    "    result = predict_optimal_price(**scenario)\n",
                    "    \n",
                    "    print(f\"\\nüìã Scenario {i}:\")\n",
                    "    print(f\"   Original Price: {scenario['original_price']:.2f} gold coins\")\n",
                    "    print(f\"   Inventory: {scenario['inventory_level']} items\")\n",
                    "    print(f\"   Holiday: {'Yes' if scenario['is_holiday'] else 'No'}\")\n",
                    "    print(f\"   Weekend: {'Yes' if scenario['is_weekend'] else 'No'}\")\n",
                    "    print(f\"   Competitor Price: {scenario['competitor_price']:.2f} gold coins\")\n",
                    "    print(f\"   \\nüéØ AI Recommendation:\")\n",
                    "    print(f\"   Optimal Price: {result['optimal_price']:.2f} gold coins\")\n",
                    "    print(f\"   Expected Demand: {result['predicted_demand']:.1f} items\")\n",
                    "    print(f\"   Expected Revenue: {result['predicted_revenue']:.2f} gold coins\")\n",
                    "    print(f\"   Price Change: {result['price_change_pct']:+.1f}%\")\n",
                    "\n",
                    "print(\"\\nüéâ Our AI-powered pricing spell is working brilliantly!\")"
                ]
            }
        ],
        "metadata": {
            "kernelspec": {
                "display_name": "Python 3",
                "language": "python",
                "name": "python3"
            },
            "language_info": {
                "codemirror_mode": {
                    "name": "ipython",
                    "version": 3
                },
                "file_extension": ".py",
                "mimetype": "text/x-python",
                "name": "python",
                "nbconvert_exporter": "python",
                "pygments_lexer": "ipython3",
                "version": "3.8.5"
            }
        },
        "nbformat": 4,
        "nbformat_minor": 4
    }
    
    return notebook

def main():
    """Create and save the notebook"""
    notebook = create_notebook()
    
    with open('dynamic_pricing_elf_guide.ipynb', 'w') as f:
        json.dump(notebook, f, indent=2)
    
    print("‚ú® Jupyter notebook created successfully!")

if __name__ == "__main__":
    main()